import './style.css'
import { UnrealBloomPass} from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
import * as THREE from 'three'
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import {ShaderPass} from "three/examples/jsm/postprocessing/ShaderPass";
import {EffectComposer} from "three/examples/jsm/postprocessing/EffectComposer";
import * as dat from 'dat.gui'
import gsap from 'gsap'
import CSG from './three-csg.js'
import MathUtils from 'three/src/math/MathUtils'
import {MathUtil} from "three/examples/jsm/libs/OimoPhysics";
//const ThreeBSP = require('three-js-csg/index.js')(THREE);

/**
 * Base
 */
var kurac;
const gui = new dat.GUI();
//const moveGUI = document.querySelector('div.moveGUI')
//var customContainer = moveGUI.append(gui.domElement);
var utripanjeYesNo = true;
var animiramoYesNo = true;

var params = {
    exposure: 1,
    bloomStrength: 1.0,
    bloomThreshold: 0.1,
    bloomRadius: 0.1,
    utripanjeYesNo: true,
    animiramoYesNo: true
};

/**
 * Sizes
 */
const sizes = {
    width: window.innerWidth,
    height: window.innerHeight
}

window.addEventListener('resize', () =>
{
    // Update sizes
    sizes.width = window.innerWidth
    sizes.height = window.innerHeight

    // Update camera
    camera.aspect = sizes.width / sizes.height
    camera.updateProjectionMatrix()

    // Update renderer
    renderer.setSize(sizes.width, sizes.height)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
})


var container, stats;
var composer;

var camera, scene, renderer;

var group;

const data = {
    text: '-ise, veljavno do 18. Oktobra'
}

var targetRotation = 0;
var targetRotationOnMouseDown = 0;

var ringCSG;
var engravedMesh;
var mesh;
//var text;
//var textGeometry;
//var textMaterial;
var bloomPass;

const scale = 1;
var emitter;
const canvas = document.querySelector('canvas.webgl');
let time;
const clock = new THREE.Clock();
//canvas.style.backgroundImage = url("https://cdn.wallpapersafari.com/76/64/XtMHpr.jpg");
//.style.backgroundColor = url('3.png')
//canvas.style.backgroundSize = 'cover'

init();
window.onload = function() {
    animate()
};
//animate();
function init() {

    time = Date.now();

    console.log('init');
    container = document.createElement( 'div' );
    container.appendChild(canvas);

    document.body.appendChild( container );

    scene = new THREE.Scene();
    scene.background = null;

    camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
    camera.position.set( 100, 350, 0 );
    scene.add(camera);

    var light = new THREE.PointLight( 0xffffff, 0.9 );
    camera.add( light );

    group = new THREE.Group();
    group.position.y = 0;
    //scene.add( group );

    var loader = new THREE.TextureLoader();
    const texture = loader.load( "3.png" );
    //var matcapTextureText = loader.load('8.png')
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set( 0.008, 0.008 );

    function addShape( shape, extrudeSettings, color, x, y, z, rx, ry, rz, s ) {

        console.log('adding shape')
        // flat shape with texture
        // note: default UVs generated by ShapeGemoetry are simply the x- and y-coordinates of the vertices

        var geometry = new THREE.ExtrudeGeometry( shape, extrudeSettings );

        //const material = new THREE.MeshMatcapMaterial()
        //material.matcap = matcapTexture
        mesh = new THREE.Mesh( geometry, new THREE.MeshMatcapMaterial({ color: color } ) );
        mesh.material.matcap = texture;
        mesh.material.roughness = 0.65
        mesh.material.metalness = 0.45
        mesh.material.reflectivity = 0.8
        mesh.material.shininess = 100
        //mesh.material.wireframe = true
        //gui.add(mesh.material, 'metalness', 0, 1, 0.01)
        mesh.position.set( x, y, z );
        mesh.rotation.set( rx, ry, rz );
        mesh.scale.set( s, s, s );
        scene.add(mesh)
        //group.add( mesh );

        // ringCSG = CSG.fromMesh(mesh) //- orig
        // var ringMesh = CSG.toMesh(ringCSG, new THREE.Matrix4())
        // ringMesh.scale.set(4,4,4)

        const fontLoader = new THREE.FontLoader()
        fontLoader.load(
            '../static/fonts/Mf Love Song_Regular.json',
            (font) => {

                const textGeometry = new THREE.TextBufferGeometry(
                    '18. Oktoberrrrr',
                    {
                        font: font,
                        size: 10.5,
                        height: 3.2,
                        curveSegments: 5,
                        bevelEnabled: true,
                        bevelThickness: 0.03,
                        bevelSize: 0.02,
                        bevelOffset: 0,
                        bevelSegments: 4
                    }
                )
                textGeometry.center()
                const textMaterial = new THREE.MeshMatcapMaterial({matcap: texture})
                const text = new THREE.Mesh(textGeometry, textMaterial)
                text.name = "Oktober";
                text.position.set(-20, 30, 50)
                text.lookAt(camera.position)
                //text.rotation.copy(camera.position)
                text.position.copy(camera.position)
                //text.updateMatrix()
                text.translateZ(-100)
                //text.rotateOnAxis(1, 70)
                //console.log(text)
                scene.add(text)
                scene.add(mesh)
            }
        )

    }

    // Arc circle 1
    var x = 0, y = 0;
    var arcShape1 = new THREE.Shape();
    arcShape1.moveTo( 0, 0 );
    arcShape1.absarc( 10, 10, 11, 0, Math.PI*1.99, false );

    var holePath1 = new THREE.Path();
    holePath1.moveTo( 20, 10 );
    holePath1.absarc( 10, 10, 10, 0, Math.PI*2.01, true );
    arcShape1.holes.push( holePath1 );
    //

    // Arc circle 2
    var x = 0, y = 0;
    var arcShape2 = new THREE.Shape();
    arcShape2.moveTo( 0, 0 );
    arcShape2.absarc( 10, 10, 13, 0, Math.PI*2, false );

    var holePath2 = new THREE.Path();
    holePath2.moveTo( 25, 10 );
    holePath2.absarc( 10, 10, 12, 0, Math.PI*2, true );
    arcShape2.holes.push( holePath2 );
    //

    var extrudeSettings = { amount: 1.6, bevelEnabled: true, bevelSegments: 80, steps: 60, bevelSize: 0.6, bevelThickness: 1.8, curveSegments: 150 };
    //var extrudeSettings = { amount: 1.6, bevelEnabled: true, bevelSegments: 1, steps: 1, bevelSize: 0.6, bevelThickness: 1.8, curveSegments: 10 };
    // addShape( shape, color, x, y, z, rx, ry,rz, s );

    //addShape( heartShape,       extrudeSettings, 0xf00000,   60,  100, 0, 0, 0, Math.PI, 1 );
    //addShape( arcShape1, extrudeSettings, 0xffc107,  -35, -30, -20, 0, 0, 0, 4 );
    addShape( arcShape2, extrudeSettings, 0xffc107,  -40, -22, -50, 0, 0, 0, 4 );


    renderer = new THREE.WebGLRenderer( {
        antialias: true,
        alpha: true
    } );
    //canvas.appendChild(renderer.domElement)
    renderer.domElement.id = 'MainCanva'
    renderer.setClearColor('white', 0);
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( sizes.width, sizes.height );
    //renderer.shadowMapEnabled = true;
    //renderer.shadowMapType = THREE.PCFSoftShadowMap;
    group.castShadow = true;
    group.receiveShadow = false;

    //bloom effect hopefully
    var renderScene = new RenderPass(scene, camera);

    bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight),params.bloomStrength, params.bloomRadius, params.bloomThreshold);
    /* bloomPass.renderToScreen = true; */
    bloomPass.threshold = params.bloomThreshold;
    bloomPass.strength = params.bloomStrength;
    bloomPass.radius = params.bloomRadius;


    composer = new EffectComposer( renderer );
    composer.setSize(sizes.width, sizes.height);
    composer.addPass( renderScene );
    composer.addPass( bloomPass );

    container.appendChild( renderer.domElement );
    console.log(container);
    var controls = new OrbitControls( camera, renderer.domElement );
    controls.enableDamping = true;
    renderer.setSize( sizes.width, sizes.height );


    gui.add( params, 'exposure', 0.1, 2 ).onChange( function ( value ) {

        renderer.toneMappingExposure = Math.pow( value, 4.0 );

    } );

    gui.add( params, 'bloomThreshold', 0.0, 1.0 ).onChange( function ( value ) {

        bloomPass.threshold = Number( value );

    } );

    gui.add( params, 'bloomStrength', 0.0, 3.0 ).onChange( function ( value ) {

        bloomPass.strength = Number( value );

    } );

    gui.add( params, 'bloomRadius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {

        bloomPass.radius = Number( value );

    } );

    gui.add( params, 'utripanjeYesNo').onChange( function ( value ) {
        utripanjeYesNo = value;
    })

    gui.add( params, 'animiramoYesNo').onChange( function ( value ) {
        animiramoYesNo = value;
    })


    window.addEventListener( 'resize', onWindowResize );

}

function bend(geometry, axis, angle) {
    console.log('omg im bending')
    let theta = 0;
    if (angle !== 0) {
        const v = geometry.attributes.position.array;
        for (let i = 0; i < v.length; i += 3) {
            let x = v[i];
            let y = v[i + 1];
            let z = v[i + 2];
            switch (axis) {
                case "x":
                    theta = z * angle;
                    break;
                case "y":
                    theta = x * angle;
                    break;
                default: //z
                    theta = x * angle;
                    break;
            }
            let sinTheta = Math.sin(theta);
            let cosTheta = Math.cos(theta);
            switch (axis) {
                case "x":
                    v[i] = x;
                    v[i + 1] = (y - 1.0 / angle) * cosTheta + 1.0 / angle;
                    v[i + 2] = -(y - 1.0 / angle) * sinTheta;
                    break;
                case "y":
                    v[i] = -(z - 1.0 / angle) * sinTheta;
                    v[i + 1] = y;
                    v[i + 2] = (z - 1.0 / angle) * cosTheta + 1.0 / angle;
                    break;
                default: //z
                    v[i] = -(y - 1.0 / angle) * sinTheta;
                    v[i + 1] = (y - 1.0 / angle) * cosTheta + 1.0 / angle;
                    v[i + 2] = z;
                    break;
            }
        }
        geometry.attributes.position.needsUpdate = true;
    }
}

function regenerateGeometry(font, x, y, z) {
    console.log('regenerating')
    let newGeometry
    let newMesh
    let newGeometry2

    // newGeometry =  new THREE.Mesh(new THREE.BoxGeometry(10,10,20), new THREE.MeshBasicMaterial({color:'pink'}))
    //newGeometry.position.add(new THREE.Vector3(80.5, 70.5, 0.5))
    // newGeometry.scale.set(4,4,4)
    // newGeometry.position.add(new THREE.Vector3(-80, -20, -60))
    //console.log(newGeometry.)
    //scene.add(newGeometry)

    newGeometry2 =  new THREE.Mesh(new THREE.BoxGeometry(10,10,10), new THREE.MeshBasicMaterial({color:'blue'}))
    newGeometry2.scale.set(4,4,4)
    newGeometry2.position.set(-85, -20, -20)
    //newGeometry2.updateMatrix()
    //scene.add(newGeometry2)

    newGeometry = new THREE.TextBufferGeometry(data.text, {
        font: font,
        size: 5,
        height: 0.2,
        curveSegments: 2
    })
    //newGeometry.center()
    //bend(newGeometry, 'z', Math.PI / 100)
    newMesh = new THREE.Mesh(newGeometry, new THREE.MeshBasicMaterial({color:'blue'}))
    scene.add(newMesh)

    console.log("textCSG position")
    const textCSG2 = CSG.fromMesh(newMesh)

    //var engravedCSG = ringCSG.subtract(textCSG) - orig
    var engravedCSG = ringCSG.subtract(textCSG2)
    engravedMesh.geometry.dispose()
    engravedMesh.geometry = CSG.toMesh(
        engravedCSG,
        new THREE.Matrix4()
    ).geometry

    // !! EXPERIMENT !!
    // newGeometry.updateMatrix()
    // newGeometry2.updateMatrix()
    // const box1 = CSG.fromMesh(newGeometry)
    // const box2 = CSG.fromMesh(newGeometry2)
    //
    // const box_result = box1.subtract(box2)
    // scene.add(CSG.toMesh(box_result, newGeometry.matrix, newGeometry.material))
    //
}
function onWindowResize() {

    //text.lookAt(camera.position)
    //console.log(text)
    const width = window.innerWidth;
    const height = window.innerHeight;

    camera.aspect = width / height;
    camera.updateProjectionMatrix();

    renderer.setSize( width, height );
    composer.setSize( width, height );

}

function animate() {
    scene.getObjectByName("Oktober").rotation.copy(camera.rotation)
    scene.getObjectByName("Oktober").position.copy(camera.position)
    scene.getObjectByName("Oktober").updateMatrix();
    scene.getObjectByName("Oktober").translateZ(-100)
    scene.getObjectByName("Oktober").translateY(-25)
    //console.log(camera.position)
    const currentTime = Date.now()
    const deltaTimeb = currentTime - time
    time = currentTime
    // Clock - elapsed time since initialization of clock
    const elapsedTime = clock.getElapsedTime()
    //mesh.rotation.y = elapsedTime
    if(animiramoYesNo){
        mesh.rotation.x = Math.sin(elapsedTime)
        mesh.rotation.y = Math.cos(elapsedTime)
        mesh.rotation.z = Math.sin(elapsedTime)
        mesh.position.z = Math.cos(elapsedTime) * 100
        mesh.position.x = Math.sin(elapsedTime) * 100
        mesh.position.y = Math.cos(elapsedTime) * 100
    }

    if(utripanjeYesNo){
        bloomPass.threshold = -0.5 +  Math.abs(Math.sin(elapsedTime * 0.5)) * 1.15;
        bloomPass.strength = 1.3 + Math.abs(Math.sin(elapsedTime)) * 1.5;
        bloomPass.radius = Math.abs(Math.sin(elapsedTime));
    }



    requestAnimationFrame( animate );
    render();

}

function render() {
    renderer.render( scene, camera );
    composer.render();

}
